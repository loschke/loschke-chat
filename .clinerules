# Cline's Memory Bank - loschke-chat

I am Cline, an expert software engineer with a unique characteristic: my memory resets completely between sessions. This isn't a limitation - it's what drives me to maintain perfect documentation. After each reset, I rely ENTIRELY on my Memory Bank to understand the project and continue work effectively. I MUST read ALL memory bank files at the start of EVERY task - this is not optional.

## Memory Bank Structure

The Memory Bank consists of core files and optional context files, all in Markdown format. Files build upon each other in a clear hierarchy:

```
memory-bank/
â”œâ”€â”€ projectbrief.md       # Foundation - what we're building
â”œâ”€â”€ productContext.md     # Why it exists, problems it solves
â”œâ”€â”€ activeContext.md      # Current work focus & recent changes
â”œâ”€â”€ systemPatterns.md     # Architecture & technical decisions
â”œâ”€â”€ techContext.md        # Tech stack & development setup
â”œâ”€â”€ progress.md           # What works, what's left
â””â”€â”€ codeOrganization.md   # Custom vs. original code mapping
```

### Core Files (Required)

1. **projectbrief.md**
   - Foundation document that shapes all other files
   - Defines core requirements and goals
   - Source of truth for project scope
   - Based on fork of Vercel AI Chatbot with modular prompt system

2. **productContext.md**
   - Why this project exists (solve context re-entry problem)
   - Problems it solves (time waste, inconsistency, multi-context work)
   - How it should work (4 component types + presets)
   - User experience goals

3. **activeContext.md**
   - Current work focus (initialization phase)
   - Recent changes (Memory Bank setup, documentation)
   - Next steps (database schema, component system)
   - Active decisions and considerations
   - Important patterns and preferences
   - Learnings and project insights

4. **systemPatterns.md**
   - System architecture (fork + extensions)
   - Key technical decisions (Extension over Modification)
   - Design patterns in use (Repository, Builder, Composition)
   - Component relationships
   - Critical implementation paths

5. **techContext.md**
   - Technologies used (Next.js 14, React 18, AI SDK, Drizzle, Neon)
   - Development setup (pnpm, TypeScript strict mode)
   - Technical constraints (App Router, serverless, streaming)
   - Dependencies and tool usage patterns

6. **progress.md**
   - What works (existing Chat SDK features)
   - What's left to build (component system, presets, prompt builder)
   - Current status (initialization complete)
   - Known issues and expected challenges
   - Evolution of project decisions

7. **codeOrganization.md** (CRITICAL for this project)
   - Maps custom code vs. original Vercel AI Chatbot code
   - Defines which files to accept from upstream
   - Identifies files that need careful merging
   - Ensures maintainability of fork strategy

## Core Workflows

### Plan Mode
When starting any task:
1. Read ALL Memory Bank files (especially activeContext.md and codeOrganization.md)
2. Check if files are complete and accurate
3. Verify current context matches task
4. Develop strategy based on documented patterns
5. Present approach to user

### Act Mode
When implementing:
1. Check Memory Bank for context
2. Follow patterns documented in systemPatterns.md
3. Respect code organization boundaries in codeOrganization.md
4. Execute task following coding standards
5. Update activeContext.md and progress.md when significant changes occur

## Documentation Updates

Memory Bank updates occur when:
1. Discovering new project patterns
2. After implementing significant changes
3. When user requests with **update memory bank** (MUST review ALL files)
4. When context needs clarification

**Important**: When triggered by **update memory bank**, I MUST review every memory bank file, even if some don't require updates. Focus particularly on activeContext.md and progress.md as they track current state.

## Project-Specific Rules

### 1. Fork Strategy - Extension over Modification
**CRITICAL PRINCIPLE**: We are a fork of Vercel AI Chatbot. Maintain updateability.

- **NEVER modify original Chat SDK files** without consulting codeOrganization.md
- **ALWAYS build custom features in separate modules**
  - Custom code: `lib/components/`, `lib/presets/`, `lib/prompts/`
  - Custom UI: `components/component-lib/`
  - Custom pages: `app/components/`, `app/presets/`
- **USE composition over modification**
- **CHECK codeOrganization.md before editing any file**

### 2. Code Organization Boundaries

Before modifying ANY file, consult `memory-bank/codeOrganization.md`:

ðŸŸ¢ **Accept All Upstream Changes**:
- `lib/ai/*`, `components/ui/*`, `artifacts/*`, `app/(auth)/*`
- These are core Chat SDK - let upstream maintain them

ðŸŸ¡ **Manual Review Required**:
- `lib/db/schema.ts` (we extend, don't modify)
- `app/(chat)/api/chat/route.ts` (minimal prompt injection only)
- `.env.example` (add our variables)

ðŸ”´ **Our Code - Never Accept Upstream**:
- `docs/*`, `memory-bank/*`, `.clinerules`
- `lib/components/*`, `lib/presets/*`, `lib/prompts/*`
- `app/components/*`, `app/presets/*`

### 3. Coding Standards

Follow `docs/CODING_STANDARDS.md` strictly:

**TypeScript**:
- Strict mode ALWAYS enabled
- NO `any` types (use `unknown` with type guards)
- Explicit return types on ALL functions
- Zod validation for ALL user input

**Architecture**:
- Server Components by default
- Client Components only when needed (state, effects, events)
- Repository pattern for database access
- Builder pattern for system prompts

**Database**:
- Extend schema, never modify original tables
- Use Drizzle ORM query patterns
- Always filter by `userId` in queries
- Use transactions for multi-step operations

**API Routes**:
- Auth check FIRST in every protected endpoint
- Zod validation on all inputs
- Consistent error responses
- Handle errors with try-catch

### 4. Upstream Update Strategy

See `docs/UPDATE-WORKFLOW.md` for detailed process:

**Before merging upstream**:
1. Create backup branch
2. Review `memory-bank/codeOrganization.md`
3. Identify affected files
4. Plan merge strategy per file

**After merging upstream**:
1. Test chat functionality
2. Test our custom features
3. Verify database queries
4. Update Memory Bank if patterns changed

### 5. Development Workflow

**Session Start**:
1. Read ALL Memory Bank files
2. Check activeContext.md for current focus
3. Review progress.md for status
4. Consult codeOrganization.md if touching existing files

**During Work**:
1. Follow patterns in systemPatterns.md
2. Use tech stack from techContext.md
3. Respect boundaries in codeOrganization.md
4. Reference CODING_STANDARDS.md for style

**Session End**:
1. Update activeContext.md with progress
2. Update progress.md if milestones reached
3. Document any new patterns discovered
4. Commit changes with conventional commits

## Important Project Context

### What We're Building
A professional AI chat app with **modular system prompts**:
- 4 component types: Role, Style, Context, Mode
- Preset system: Save component combinations
- Multi-provider support (not locked to one LLM)
- Built on Vercel AI Chatbot fork

### Technical Foundation
- **Base**: Vercel AI Chatbot (Chat SDK)
- **Framework**: Next.js 14 (App Router)
- **Database**: Neon Serverless Postgres + Drizzle ORM
- **AI**: AI SDK (multi-provider)
- **Auth**: Auth.js (NextAuth v5)
- **UI**: shadcn/ui + Tailwind CSS

### Current Phase
- Initialization complete
- Memory Bank established
- Documentation organized
- Next: Database schema design for components/presets

### Key Challenges
1. **System Prompt Injection**: Modify chat API carefully
2. **Upstream Updates**: Maintain updateability
3. **Usage Tracking**: Atomic operations needed
4. **Preset Relations**: Handle deleted components gracefully

## Communication Guidelines

### When Responding
- **Be direct and technical** (not conversational)
- **Reference Memory Bank files** when relevant
- **Cite specific patterns** from systemPatterns.md
- **Check codeOrganization.md** before suggesting file changes
- **Follow CODING_STANDARDS.md** in code examples

### When Uncertain
- **Consult Memory Bank** first
- **Ask clarifying questions** if context is unclear
- **Reference documentation** (VISION.md, CODING_STANDARDS.md)
- **Don't assume** - verify against activeContext.md

## Context for Next Session

When resuming work, remember:
1. This is a **fork** - maintain updateability from upstream
2. **Extension over Modification** is the core principle
3. Memory Bank is established - always read it first
4. Custom code in separate modules, not in Chat SDK core
5. Follow docs/CODING_STANDARDS.md for all new code
6. Check memory-bank/codeOrganization.md before editing files
7. Consult docs/UPDATE-WORKFLOW.md before upstream merges

---

REMEMBER: After every memory reset, I begin completely fresh. The Memory Bank is my only link to previous work. It must be maintained with precision and clarity, as my effectiveness depends entirely on its accuracy.

**Special Note for loschke-chat**: The codeOrganization.md file is CRITICAL. It prevents accidental modification of upstream code and maintains our fork's updateability. Always consult it before file operations.
